/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var MyPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    const ribbonIconEl = this.addRibbonIcon("dice", "Shorten links", (evt) => {
      this.CleanCanvas();
    });
    ribbonIconEl.addClass("my-plugin-ribbon-class");
    this.addCommand({
      id: "shorten-links-in-canvas",
      name: "Shorten links in canvas",
      callback: () => {
        this.CleanCanvas();
      }
    });
    this.registerInterval(window.setInterval(() => console.log("setInterval"), 5 * 60 * 1e3));
  }
  onunload() {
  }
  async CleanCanvas() {
    const canvasView = app.workspace.getActiveViewOfType(import_obsidian.ItemView);
    if ((canvasView == null ? void 0 : canvasView.getViewType()) !== "canvas") {
      return;
    }
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No canvas detected!");
      return;
    }
    const content = await this.app.vault.cachedRead(activeFile);
    const canvasData = JSON.parse(content);
    for (let iEdge = 0; iEdge < canvasData["edges"].length; iEdge++) {
      let fromNodeID = canvasData["edges"][iEdge]["fromNode"];
      let toNodeID = canvasData["edges"][iEdge]["toNode"];
      let fromNode = canvasData["nodes"].filter((obj) => {
        return obj.id === fromNodeID;
      })[0];
      let toNode = canvasData["nodes"].filter((obj) => {
        return obj.id === toNodeID;
      })[0];
      let distances = [];
      for (const fromSide of ["top", "bottom", "left", "right"]) {
        let fromPoint = { "x": 0, "y": 0 };
        if (fromSide == "top") {
          fromPoint = { "x": fromNode["x"], "y": fromNode["y"] - fromNode["height"] / 2 };
        } else if (fromSide == "bottom") {
          fromPoint = { "x": fromNode["x"], "y": fromNode["y"] + fromNode["height"] / 2 };
        } else if (fromSide == "left") {
          fromPoint = { "x": fromNode["x"] - fromNode["width"] / 2, "y": fromNode["y"] };
        } else if (fromSide == "right") {
          fromPoint = { "x": fromNode["x"] + fromNode["width"] / 2, "y": fromNode["y"] };
        }
        for (const toSide of ["top", "bottom", "left", "right"]) {
          let toPoint = { "x": 0, "y": 0 };
          if (toSide == "top") {
            toPoint = { "x": toNode["x"], "y": toNode["y"] - toNode["height"] / 2 };
          } else if (toSide == "bottom") {
            toPoint = { "x": toNode["x"], "y": toNode["y"] + toNode["height"] / 2 };
          } else if (toSide == "left") {
            toPoint = { "x": toNode["x"] - toNode["width"] / 2, "y": toNode["y"] };
          } else if (toSide == "right") {
            toPoint = { "x": toNode["x"] + toNode["width"] / 2, "y": toNode["y"] };
          }
          distances.push({
            "fromSide": fromSide,
            "toSide": toSide,
            "distance": (toPoint.x - fromPoint.x) ** 2 + (toPoint.y - fromPoint.y) ** 2
          });
        }
      }
      distances = distances.sort(function(a, b) {
        return a.distance - b.distance;
      });
      switch (distances[0]["fromSide"]) {
        case "top":
          canvasData["edges"][iEdge]["fromSide"] = "top";
          break;
        case "bottom":
          canvasData["edges"][iEdge]["fromSide"] = "bottom";
          break;
        case "left":
          canvasData["edges"][iEdge]["fromSide"] = "left";
          break;
        case "right":
          canvasData["edges"][iEdge]["fromSide"] = "right";
          break;
      }
      switch (distances[0]["toSide"]) {
        case "top":
          canvasData["edges"][iEdge]["toSide"] = "top";
          break;
        case "bottom":
          canvasData["edges"][iEdge]["toSide"] = "bottom";
          break;
        case "left":
          canvasData["edges"][iEdge]["toSide"] = "left";
          break;
        case "right":
          canvasData["edges"][iEdge]["toSide"] = "right";
          break;
      }
      this.app.vault.modify(activeFile, JSON.stringify(canvasData));
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
